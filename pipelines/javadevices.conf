input {
    pipeline {
        address => javadevices
    }
}
filter {
    if "multiline" in [log][flags] {
            if ! ("javadevices" in [tags]) {
                drop { }
                 }
        grok { 
            match => { 
                "message" => ['%{LOGLEVEL:[log][level]} +%{TIMESTAMP_ISO8601:[javadevices][timestamp]} +%{NOSPACE:[javadevices][devicename]} \- %{GREEDYDATA:[process][thread][name]} \| %{GREEDYDATA:[log][origin][function]}:%{INT:[log][origin][file][line]} - \n%{GREEDYDATA:[error][type]}\: +%{NOTLINEBREAK:[error][message]}\n%{GREEDYDATA:[error][stack][trace]}']
            }
            pattern_definitions => {
                "NOSPACE" => "\S*"
                "NOTLINEBREAK" => "[^\n]+"
            }
            remove_field => [ "message" ]
        }
        if "_grokparsefailure" in [tags] {
    	    grok { 
       		    match => { 
                    "message" => ['%{LOGLEVEL:[log][level]} +%{TIMESTAMP_ISO8601:[javadevices][timestamp]} +\- %{GREEDYDATA:[process][thread][name]} \| %{GREEDYDATA:[log][origin][function]}:%{INT:[log][origin][file][line]} - \n%{GREEDYDATA:[error][type]}\: +%{NOTLINEBREAK:[error][message]}\n%{GREEDYDATA:[error][stack][trace]}']
                }
                pattern_definitions => {
         	        "NOSPACE" => "\S*"
                    "NOTLINEBREAK" => "[^\n]+"
                }
       	        remove_field => [ "message" ]
            }
        }
        if "_grokparsefailure" in [tags] {
            grok { 
                match => { 
                    "message" => ['%{LOGLEVEL:[log][level]} +%{TIMESTAMP_ISO8601:[javadevices][timestamp]} +%{NOSPACE:[javadevices][devicename]} \- %{GREEDYDATA:[process][thread][name]} \| %{GREEDYDATA:[log][origin][function]}:%{INT:[log][origin][file][line]} - %{GREEDYDATA:[error][message]}\: +%{NOTLINEBREAK:[error][type]}\n%{GREEDYDATA:[error][stack][trace]}']
                }
                pattern_definitions => {
                    "NOSPACE" => "\S*"
                    "NOTLINEBREAK" => "[^\n]+"
                }
                remove_field => [ "message" ]
            }
        }
        date {
            match => [ "[javadevices][timestamp]", "ISO8601" ]
            remove_field => [ "[javadevices][timestamp]" ]
            timezone => "Europe/Paris"
        }
        mutate {
            rename => { "[fields][beamline]" => "beamline" }
            remove_field => [ "tags", "fields" ]
                }
            }
    else {
        if ! ("javadevices" in [tags]) {
            drop { }
        }
        grok { 
            match => { 
                "message" => ['%{LOGLEVEL:[log][level]} +%{TIMESTAMP_ISO8601:[javadevices][timestamp]} +%{NOSPACE:[javadevices][devicename]} \- %{GREEDYDATA:[process][thread][name]} \| %{GREEDYDATA:[log][origin][function]}:%{INT:[log][origin][file][line]} - %{GREEDYDATA:[javadevices][message]}']
            }
            pattern_definitions => {
                "NOSPACE" => "\S*"
            }
            remove_field => [ "message" ]
        }
        mutate{
            rename => {
                "[javadevices][message]" => "message"
            }
        }
        if "_grokparsefailure" in [tags] {
    	    grok { 
       		    match => { 
                    "message" => ['%{LOGLEVEL:[log][level]} +%{TIMESTAMP_ISO8601:[javadevices][timestamp]} +\- %{GREEDYDATA:[process][thread][name]} \| %{GREEDYDATA:[log][origin][function]}:%{INT:[log][origin][file][line]} - %{GREEDYDATA:[javadevices][message]}'] 
                }
                pattern_definitions => {
         	        "NOSPACE" => "\S*"
                }
       	        remove_field => [ "message" ]
            }
            mutate{
                rename => {
                    "[javadevices][message]" => "message"
                }
            }
        }
        date {
            match => [ "[javadevices][timestamp]", "ISO8601" ]
            remove_field => [ "[javadevices][timestamp]" ]
            timezone => "Europe/Paris"
        }
        mutate {
            rename => { "[fields][beamline]" => "beamline" }
            remove_field => [ "tags", "fields" ]
        }
    }
}
#output {
#    file {
#        path => "/usr/share/logstash/logs/outputdev.txt"
#    }
#}
output {   
    pipeline {
        send_to => tangocs
    }
}
