input {
    pipeline {
        address => yat4tango
    }
}
filter {
    dissect {
        mapping => {
            "message" => "%{timestamp_nanos->} | %{[log][level]} | %{[process][thread][id]} | %{[device][name]} | %{message}"
        }
    }
    ruby {
        code => '
            hexNum = event.get("[process][thread][id]")
            event.set("decNum", hexNum.to_i(16).to_s(10))
        '
    }
    ruby {
        code => "event.set('[process][thread][id]', event.get('[process][thread][id]').to_s.hex)"
      }
    
    if "_dissectfailure" in [tags] {
        drop { }
    }

    grok {
        match => {
            "[device][name]" => "(?<[device][domain]>[^_/]+)/(?<[device][family]>[^_/]+)/(?<[device][member]>%{GREEDYDATA})" 
        }
    }
    grok {
        match => {
            "[log][file][path]" => "%{GREEDYDATA}/(?<[process][name]>ds_[^/]+)/(?<[device][instance]>[^/]+)/%{GREEDYDATA}"
        }
    }
    date {
        match => [ "timestamp_nanos", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSZ" ]
    }
    mutate {
        rename => { 
            "[fields][beamline]" => "beamline"
        }
        remove_field => [ "tags", "fields" ]
    }
}
output {   
    pipeline {
        send_to => tangocs
    }
}
